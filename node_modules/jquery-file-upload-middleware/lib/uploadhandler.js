var EventEmitter = require('events').EventEmitter,
    path = require('path'),
    fs = require('fs'),
    formidable = require('formidable'),
    imageMagick = require('imagemagick'),
    mkdirp = require('mkdirp'),
    _ = require('lodash');

module.exports = function (options) {

    var FileInfo = require('./fileinfo')(
        _.extend({
            baseDir: options.uploadDir
        }, _.pick(options, 'minFileSize', 'maxFileSize', 'acceptFileTypes'))
    );

    var UploadHandler = function (req, res, callback) {
        EventEmitter.call(this);
        this.req = req;
        this.res = res;
        this.callback = callback;
    };
    require('util').inherits(UploadHandler, EventEmitter);

    UploadHandler.prototype.noCache = function () {
        this.res.set({
            'Pragma': 'no-cache',
            'Cache-Control': 'no-store, no-cache, must-revalidate',
            'Content-Disposition': 'inline; filename="files.json"'
        });
    };

    UploadHandler.prototype.get = function () {
        this.noCache();
        var files = [];

        //added optional function getFileList
        //define the function in the settings
        //options will be passed to the function
        //call the callback with an array of objects, each object must have
        //a name (filename) and a dir (directory of the file) property
        if(typeof options.getFileList == 'function'){
            options.getFileList(options,_.bind(function(list){
                _.each(list, function (file) {
                    var stats = fs.statSync(file.dir + '/' + file.name),
                        fileInfo;
                    if (stats.isFile()) {
                        fileInfo = new FileInfo({
                            name: file.name,
                            size: stats.size
                        });
                        this.initUrls(fileInfo);
                        files.push(fileInfo);
                    }
                }, this);
                this.callback(files);
            },this));
        }
        else{
            fs.readdir(options.uploadDir(), _.bind(function (err, list) {
                _.each(list, function (name) {
                    var stats = fs.statSync(options.uploadDir() + '/' + name),
                        fileInfo;
                    if (stats.isFile()) {
                        fileInfo = new FileInfo({
                            name: name,
                            size: stats.size
                        });
                        this.initUrls(fileInfo);
                        files.push(fileInfo);
                    }
                }, this);
                this.callback(files);
            }, this));
        }
    };

    UploadHandler.prototype.post = function () {

        var self = this,
            form = new formidable.IncomingForm(),
            tmpFiles = [],
            files = [],
            map = {},
            counter = 1,
            redirect,
            finish = _.bind(function () {
                if (!--counter) {
                    console.log('upload finished');
                    _.each(files, function (fileInfo) {
                        this.initUrls(fileInfo);
                        this.emit('end', fileInfo);
                    }, this);
                    this.callback(files, redirect);
                }
            }, this);

        this.noCache();

        form.uploadDir = options.tmpDir;
        form
            .on('fileBegin', function (name, file) {
                tmpFiles.push(file.path);
                var fileInfo = new FileInfo(file);
                fileInfo.safeName();
                map[path.basename(file.path)] = fileInfo;
                files.push(fileInfo);
                self.emit('begin', fileInfo);
            })
            .on('field', function (name, value) {
                console.log('Converted to jpeg');
                if (name === 'redirect') {
                    redirect = value;
                }
            })
            .on('file', function (name, file) {

                var fileInfo = map[path.basename(file.path)];
                if (fs.existsSync(file.path)) {
                    fileInfo.size = file.size;
                    if (!fileInfo.validate()) {
                        if(fs.existsSync(file.path)) fs.unlinkSync(file.path);  //added save unlink
                        return;
                    }

                    //changed name from generatePreviews to generateImageVersions
                    var generateImageVersions = function () {
                        if (options.imageTypes.test(fileInfo.name)) {
                            _.each(options.imageVersions, function (value, version) {
                                var opts = options.imageVersions[version];

                                //added dir option support
                                var dir = opts.dir || options.uploadDir() + '/' + version ;

                                // creating directory recursive
                                if (!fs.existsSync(dir))
                                    mkdirp.sync(dir);

                                counter++;
                                //added optional function process
                                //define the function in the settings (default functionality - create thumbnail)
                                //options,imageVersions options and fileInfo will be passed to the function
                                if(typeof opts.process == 'function'){
                                    opts.process(options,opts,fileInfo,_.bind(function(){
                                        finish();
                                    },this));
                                }
                                else{
                                    imageMagick.resize({
                                        width: opts.width,
                                        height: opts.height,
                                        srcPath: options.uploadDir() + '/' + fileInfo.name,
                                        dstPath: dir + '/' + fileInfo.name,
                                        customArgs: opts.imageArgs || ['-auto-orient']
                                    }, finish);
                                }
                            });
                        }
                    }

                    if (!fs.existsSync(options.uploadDir() + '/'))
                        mkdirp.sync(options.uploadDir() + '/');

                    counter++;
                    fs.rename(file.path, options.uploadDir() + '/' + fileInfo.name, function (err) {
                        if (!err) {
                            //added optional function beforeProcessing
                            //define the function in the settings
                            //options and fileInfo will be passed to the function
                            if(typeof options.beforeProcessing == 'function'){
                                options.beforeProcessing(options,fileInfo,_.bind(function(){
                                    generateImageVersions();
                                    finish();
                                },this));
                            }
                            else{
                                generateImageVersions();
                                finish();
                            }
                        } else {
                            var is = fs.createReadStream(file.path);
                            var os = fs.createWriteStream(options.uploadDir() + '/' + fileInfo.name);
                            is.on('end', function (err) {
                                if (!err) {
                                    if(fs.existsSync(file.path)) fs.unlinkSync(file.path);  //added save unlink
                                    //added optional function beforeProcessing
                                    //define the function in the settings
                                    //options and fileInfo will be passed to the function
                                    if(typeof options.beforeProcessing == 'function'){
                                        counter++;
                                        options.beforeProcessing(options,fileInfo,_.bind(function(){
                                            counter--;
                                            generateImageVersions();
                                            finish();
                                        },this));
                                    }
                                    else{
                                        generateImageVersions();
                                        finish();
                                    }
                                }
                                else{
                                    finish();
                                }
                            });
                            is.pipe(os);
                        }
                    });
                }
            })
            .on('aborted', function () {
                _.each(tmpFiles, function (file) {
                    var fileInfo = map[path.basename(file)];
                    self.emit('abort', fileInfo);
                    if(fs.existsSync(file)) fs.unlink(file);  //added save unlink
                });
            })
            .on('error', function (e) {
                self.emit('error', e);
            })
            .on('progress', function (bytesReceived, bytesExpected) {
                if (bytesReceived > options.maxPostSize)
                    self.req.connection.destroy();
            })
            .on('end', finish)
            .parse(self.req);
    };


    UploadHandler.prototype.destroy = function () {
        var self = this,
            fileName = path.basename(decodeURIComponent(this.req.url));

        fs.unlink(options.uploadDir() + '/' + fileName, function (ex) {
            _.each(options.imageVersions, function (value, version) {
                //added options dir and extname support
                var opts = options.imageVersions[version];
                var dir = opts.dir || options.uploadDir() + '/' + version;
                if(opts.extname){
                    fileName = path.basename(fileName, path.extname(fileName)) + '.' + opts.extname;
                }
                if(fs.existsSync(dir + '/' + fileName))
                    fs.unlink(dir + '/' + fileName); //added save unlink
            });
            self.emit('delete', fileName);
            self.callback(!ex);
        });
    };

    UploadHandler.prototype.initUrls = function (fileInfo) {
        var baseUrl = (options.ssl ? 'https:' : 'http:') + '//' + (options.hostname || this.req.get('Host'));
        fileInfo.setUrl(null, baseUrl + options.uploadUrl());
        fileInfo.setUrl('delete', baseUrl + this.req.originalUrl);

        _.each(options.imageVersions, function (value, version) {
            var opts = options.imageVersions[version];

            var dir = opts.dir || options.uploadDir() + '/' + version;

            if(opts.extname){
                var originalFileName = fileInfo.name;
                fileInfo.name = path.basename(fileInfo.name, path.extname(fileInfo.name)) + '.' + opts.extname;
            }

            if (fs.existsSync(dir + '/' + fileInfo.name)) {
                //added dir and extname option support
                var url = opts.url || baseUrl + options.uploadUrl() + '/' + version;

                fileInfo.setUrl(version, url);
            }
            if(opts.extname) fileInfo.name = originalFileName;
        }, this);
    };

    return UploadHandler;
}

